### ekf config file ###
ekf_filter_node:
  ros__parameters:
    # The frequency, in Hz, at which the filter will output a position estimate
    frequency: 30.0

    # The period, in seconds, after which we consider a sensor to have timed out
    sensor_timeout: 0.1

    # Whether to publish the acceleration state
    publish_acceleration: false

    # Whether to publish the transform between the world_frame and the base_link frame
    publish_tf: true

    # REP-105 (http://www.ros.org/reps/rep-0105.html) specifies four principal coordinate frames: base_link, odom, map, and
    # earth. base_link is the coordinate frame that is rigidly attached to the mobile robot base. odom is a world-fixed
    # frame. The relative pose of base_link in the odom frame can drift over time but is locally accurate. The map frame
    # is a world-fixed frame. The relative pose of base_link in the map frame should not drift over time, but is not
    # always locally accurate. The earth frame is used for GPS coordinates.
    map_frame: map              # Defaults to "map" if unspecified
    odom_frame: odom            # Defaults to "odom" if unspecified
    base_link_frame: base_link  # Defaults to "base_link" if unspecified
    world_frame: odom           # Defaults to the value of odom_frame if unspecified

    # Use this parameter to provide an offset to the transform generated by ekf_localization_node. This can be used for
    # future dating the transform, which is required for interaction with some other packages. Defaults to 0.0 if
    # unspecified.
    transform_time_offset: 0.0

    # Use this parameter to provide specify how long the tf listener should wait for a transform to become available. 
    # Defaults to 0.0 if unspecified.
    transform_timeout: 0.0

    # If you're having trouble, try setting this to true, and then echo the /diagnostics_agg topic to see if the node's
    # health is being reported. Defaults to false if unspecified.
    print_diagnostics: true

    # Debug settings. Not for the faint of heart. Outputs a ludicrous amount of information to the file specified by
    # debug_out_file. I hope you like matrices! Please note that setting this to true will have strongly deleterious
    # effects on the performance of the node. Defaults to false if unspecified.
    debug: false

    # Defaults to "robot_localization_debug.txt" if unspecified.
    debug_out_file: /tmp/debug_ekf_localization.txt

    # The filter accepts an arbitrary number of inputs from each input message type (Odometry, PoseStamped,
    # TwistStamped, Imu). To add a new one, simply append the next number in the sequence to its base name, e.g.,
    # odom0.0, odom1, twist0.0, twist1, imu0.0, imu1, imu2, etc. The value should be the topic name. These parameters
    # obviously have no default values, and must be specified.
    odom0: /atlas_robot/odom
    # pose0: /initialpose

    # The filter will attempt to correct for noisy input by removing spurious measurements. If the measurement time stamp
    # is Î´t seconds in the past, then the filter will predict the state to that measurement's time stamp, then run
    # the update step with that measurement. As dt may be very small, the filter may have to make very many predictions.
    # If false, all measurements will be processed when received. This will result in out of sequence updates when
    # sensors are not all operating at the same frequency, but it may eliminate the overhead that can be introduced by
    # the predict step.
    permit_corrected_publication: false

    # Each sensor reading updates some or all of the filter's state. These options give you greater control over which
    # values from each measurement are fed to the filter. For example, if you have an odometry message as input, but
    # only want to use its Z position value, then set the entire vector to false, except for the third entry.
    # The order of the values is x, y, z, roll, pitch, yaw, vx, vy, vz, vroll, vpitch, vyaw, ax, ay, az.
    # Note that not some message types lack certain variables. For example, a TwistStamped message has no pose
    # information, so the first six values would be meaningless in that context. Each vector defaults to all false
    # if unspecified, effectively making this parameter mandatory.

    # Odometry from wheel encoders and robot motion
    odom0_config: [true,  true,  false,
                   false, false, true,
                   true,  true,  false,
                   false, false, true,
                   false, false, false]

    # If you have high-frequency data or are running with a low frequency parameter value, then you may want to increase
    # the size of the subscription queue so that more measurements are fused.
    odom0_queue_size: 10

    # [ADVANCED] Some users may want to provide a custom subscriber queue size for one or more sensors.
    # For example, if we were processing the messages in the order received, then a queue size of 1 would be
    # appropriate. However, this is not always the case.
    odom0_nodelay: false

    # [ADVANCED] When measuring one pose variable and one velocity variable from the same sensor, the resultant 
    # covariance matrix is no longer diagonal (the pose and velocity variables are coupled). This means that the 
    # measurement's covariance matrix is no longer diagonalizable, which can lead to issues in computation. To get 
    # around this, users should either not fuse both pose and velocity variables from the same sensor, or make use 
    # of the differential parameter. When differential mode is enabled, all absolute pose data is converted to velocity 
    # data by differentiating the absolute pose between two time steps. These velocities are then integrated as usual.
    odom0_differential: false

    # [ADVANCED] When the node starts, if this parameter is true, then the first measurement is treated as a "zero
    # point" for all future measurements. While you can achieve the same effect with the differential paremeter, the
    # key difference is that the relative parameter doesn't cause the measurement to be converted to a velocity before
    # integration. If you simply want your measurements to start at 0 for a given sensor, set this to true.
    odom0_relative: false

    # [ADVANCED] If your data is subject to outliers, use these threshold settings, expressed as Mahalanobis distances,
    # to control how far away from the current vehicle state a sensor measurement is allowed to be. Each defaults to
    # numeric_limits<double>::max() if unspecified.
    odom0_pose_rejection_threshold: 5.0
    odom0_twist_rejection_threshold: 1.0

    # [ADVANCED] This represents the initial value for the state estimate error covariance matrix. Setting a diagonal
    # value (variance) to a large value will result in rapid convergence for initial measurements of the respective
    # variable. Users should take care not to use large values for variables that will not be measured directly. The
    # values are ordered as x, y, z, roll, pitch, yaw, vx, vy, vz, vroll, vpitch, vyaw, ax, ay, az. Defaults to the
    # matrix below if unspecified.
    initial_estimate_covariance: [1e-9, 0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.0,     0.0,    0.0,    0.0,
                                  0.0,    1e-9, 0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.0,     0.0,    0.0,    0.0,
                                  0.0,    0.0,    1e-9, 0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.0,     0.0,    0.0,    0.0,
                                  0.0,    0.0,    0.0,    1e-9, 0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.0,     0.0,    0.0,    0.0,
                                  0.0,    0.0,    0.0,    0.0,    1e-9, 0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.0,     0.0,    0.0,    0.0,
                                  0.0,    0.0,    0.0,    0.0,    0.0,    1e-9, 0.0,    0.0,    0.0,    0.0,     0.0,     0.0,     0.0,    0.0,    0.0,
                                  0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    1e-9, 0.0,    0.0,    0.0,     0.0,     0.0,     0.0,    0.0,    0.0,
                                  0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    1e-9, 0.0,    0.0,     0.0,     0.0,     0.0,    0.0,    0.0,
                                  0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    1e-9, 0.0,     0.0,     0.0,     0.0,    0.0,    0.0,
                                  0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    1e-9,  0.0,     0.0,     0.0,    0.0,    0.0,
                                  0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     1e-9,  0.0,     0.0,    0.0,    0.0,
                                  0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     1e-9,  0.0,    0.0,    0.0,
                                  0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.0,     1e-9, 0.0,    0.0,
                                  0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.0,     0.0,    1e-9, 0.0,
                                  0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.0,     0.0,    0.0,    1e-9]

    # [ADVANCED] This represents the process noise covariance matrix. In general, the larger these values, the more
    # quickly the filter will converge, but at the expense of accuracy. The values are ordered as x, y, z, roll, pitch,
    # yaw, vx, vy, vz, vroll, vpitch, vyaw, ax, ay, az. Defaults to the matrix below if unspecified.
    process_noise_covariance: [0.05, 0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,
                               0.0,    0.05, 0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,
                               0.0,    0.0,    0.06, 0.0,    0.0,    0.0,    0.0,     0.0,     0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,
                               0.0,    0.0,    0.0,    0.03, 0.0,    0.0,    0.0,     0.0,     0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,
                               0.0,    0.0,    0.0,    0.0,    0.03, 0.0,    0.0,     0.0,     0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,
                               0.0,    0.0,    0.0,    0.0,    0.0,    0.06, 0.0,     0.0,     0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,
                               0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.025, 0.0,     0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,
                               0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.025, 0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,
                               0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.04, 0.0,    0.0,    0.0,    0.0,    0.0,    0.0,
                               0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.0,    0.01, 0.0,    0.0,    0.0,    0.0,    0.0,
                               0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.0,    0.0,    0.01, 0.0,    0.0,    0.0,    0.0,
                               0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.0,    0.0,    0.0,    0.02, 0.0,    0.0,    0.0,
                               0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.0,    0.0,    0.0,    0.0,    0.01, 0.0,    0.0,
                               0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.0,    0.0,    0.0,    0.0,    0.0,    0.01, 0.0,
                               0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.0,     0.0,     0.0,    0.0,    0.0,    0.0,    0.0,    0.0,    0.015]